/*
 * Copyright (C) 2012-2016  Politecnico di Milano
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef BBQUE_RTLIB_H_
#define BBQUE_RTLIB_H_

#include <stdint.h>
#include <time.h>
#include "assert.h"

#include <bbque/config.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief The RTLib main version
 * @ingroup rtlib_sec03_plain_services
 *
 * It must match against the BarbequeRTRM main version
 */
#define RTLIB_VERSION_MAJOR 1

/**
 * @brief The RTLib revision version
 * @ingroup rtlib_sec03_plain_services
 */
#define RTLIB_VERSION_MINOR 4

/**
 * @brief The maximum length for a recipe name
 * @ingroup rtlib_sec03_plain_exc
 *
 * Each EXC got its own recipe. The recipe contains the optimal resource
 * allocations (aka Applications Working Modes or AWMs) that have been
 * find using a Design Space Exploration phase. Note that not all the scheduling
 * policies use recipes, but, for compatibility's sake, all EXCs must provide
 * the Resource Manager with a resources.
 */
#define RTLIB_RECIPE_NAME_LENGTH 64

/**
 * @brief the maximum length for hostnames
 *
 * When the BarbequeRTRM runs in distributed environment, it notifies resource
 * assignment to applications by sending them a list of assigned resources
 * for each system. Hence, hostnames must be tracked.
 */
#define RTLIB_MAX_HOSTNAME_LENGTH 256

// Forward declarations
typedef struct RTLIB_Services RTLIB_Services_t;
typedef struct RTLIB_APIVersion RTLIB_APIVersion_t;
typedef struct RTLIB_WorkingModeParams RTLIB_WorkingModeParams_t;
typedef struct RTLIB_EXCParameters RTLIB_EXCParameters_t;
typedef struct RTLIB_Constraint RTLIB_Constraint_t;

/*******************************************************************************
 *    RTLib Types
 ******************************************************************************/

/**
 * @brief The Execution Context (EXC) programming language.
 * @ingroup rtlib_sec03_plain_services
 */
typedef enum RTLIB_ProgrammingLanguage
{
	/** Undefined application language */
	RTLIB_LANG_UNDEF = 0,
	/** C coded EXC */
	RTLIB_LANG_C = 1,
	/** CPP coded EXC */
	RTLIB_LANG_CPP = 2,
	/** Applications using a task-graph based approach (e.g., libpmsl) */
	RTLIB_LANG_TASKGRAPH = 4,
	/** OpenCL kernels included */
	RTLIB_LANG_OPENCL = 8,
	/** NVIDIA CUDA kernels included */
	RTLIB_LANG_CUDA = 16,

	RTLIB_LANG_COUNT
} RTLIB_ProgrammingLanguage_t;

/**
 * @brief Return code generated by RTLib services
 * @ingroup rtlib_sec03_plain_services
 */
typedef enum RTLIB_ExitCode
{
	/** Success (no errors) */
	RTLIB_OK = 0,
	/** Unspecified (generic) error */
	RTLIB_ERROR,
	/** RTLib Version does not match that of the Barbeque RTRM */
	RTLIB_VERSION_MISMATCH,
	/** No new working mode error */
	RTLIB_NO_WORKING_MODE,

	//---- Barbeque Communication errors

	/** Failed to setup the channel to connect the Barbeque RTRM */
	RTLIB_BBQUE_CHANNEL_SETUP_FAILED,
	/** Failed to release the channel to connect the Barbeque RTRM */
	RTLIB_BBQUE_CHANNEL_TEARDOWN_FAILED,
	/** Failed to write to the Barbeque RTRM communication channel */
	RTLIB_BBQUE_CHANNEL_WRITE_FAILED,
	/** Failed to read form the Barbeque RTRM communication channel */
	RTLIB_BBQUE_CHANNEL_READ_FAILED,
	/** Timeout on read form the Barbeque RTRM communication channel */
	RTLIB_BBQUE_CHANNEL_READ_TIMEOUT,
	/** The bbque and application RPC protocol versions does not match */
	RTLIB_BBQUE_CHANNEL_PROTOCOL_MISMATCH,
	/** The (expected) communicaiton channel is not available */
	RTLIB_BBQUE_CHANNEL_UNAVAILABLE,
	/** The (expected) response has gone in TIMEOUT */
	RTLIB_BBQUE_CHANNEL_TIMEOUT,
	/** The Barbeque RTRM is not available */
	RTLIB_BBQUE_UNREACHABLE,

	//---- EXC Management errors

	/** The Execution Context Duplicated */
	RTLIB_EXC_DUPLICATE,
	/** The Execution Context has not been registered */
	RTLIB_EXC_NOT_REGISTERED,
	/** The Execution Context Registration Failed */
	RTLIB_EXC_REGISTRATION_FAILED,
	/** The Execution Context Registration Failed */
	RTLIB_EXC_MISSING_RECIPE,
	/** The Execution Context Unregistration Failed */
	RTLIB_EXC_UNREGISTRATION_FAILED,
	/** The Execution Context has not been started yet */
	RTLIB_EXC_NOT_STARTED,
	/** The Execution Context Start Failed */
	RTLIB_EXC_ENABLE_FAILED,
	/** The Execution Context is not currently enabled */
	RTLIB_EXC_NOT_ENABLED,
	/** The Execution Context Stop Failed */
	RTLIB_EXC_DISABLE_FAILED,
	/** Failed to get a working mode */
	RTLIB_EXC_GWM_FAILED,

	//---- Reconfiguration actions required for an EXC
	// NOTE these values should match (in number and order) those defined by the
	//      ApplicationStatusIF::SyncState_t

	/** Start running on the assigned AWM */
	RTLIB_EXC_GWM_START,
	/** Reconfiguration into a different AWM */
	RTLIB_EXC_GWM_RECONF,
	/** Migration and reconfiguration into a different AWM */
	RTLIB_EXC_GWM_MIGREC,
	/** Migration (still running on the same AWM) */
	RTLIB_EXC_GWM_MIGRATE,
	/** EXC suspended (resources not available) */
	RTLIB_EXC_GWM_BLOCKED,

	//---- Internal values not exposed to applications

	/** The EXC is in sync mode */
	RTLIB_EXC_SYNC_MODE,
	/** A step of the synchronization protocol has failed */
	RTLIB_EXC_SYNCP_FAILED,
	/** No more workload to process */
	RTLIB_EXC_WORKLOAD_NONE,
	/** Unable to identify the CGRoup path */
	RTLIB_EXC_CGROUP_NONE,

	// NOTE The last entry should not overflow a uint8_t, otherwise some of the RPC
	// channel messages should be updated

	RTLIB_EXIT_CODE_COUNT

} RTLIB_ExitCode_t;

/**
 * @brief The operation requested on a resource constraint.
 * @ingroup rtlib_sec03_plain_constr
 */
typedef enum RTLIB_ConstraintOperation
{
	/** Remove the specified constraint */
	CONSTRAINT_REMOVE = 0,
	/** Add the specified constraint */
	CONSTRAINT_ADD
} RTLIB_ConstraintOperation_t;

/**
 * @brief The possible boundary asserted by a resource constraint.
 * @ingroup rtlib_sec03_plain_constr
 *
 * The EXC can constrain its resource allocation, i.e. it can tell the
 * BarbequeRTRM not to take into account some of the AWMs contained in the
 * recipe.
 */
typedef enum RTLIB_ConstraintType
{
	/** Targets AWMs lower or equal to the specified one */
	LOWER_BOUND = 0,
	/** Targets AWMs higher or equal to the specified one */
	UPPER_BOUND,
	/** Targets the specified AWM */
	EXACT_VALUE
} RTLIB_ConstraintType_t;

/**
 * @brief The synchronization flavor.
 * @ingroup rtlib_sec03_plain_exc
 */
typedef enum RTLIB_SyncType
{
	/** @brief A stateless synchronization point.
	 * When an application is on a STATELESS synchronization point,
	 * the current working mode could be switched without saving any current
	 * status, thus this is usually associated to a lower switching overhead */
	RTLIB_SYNC_STATELESS = 0,
	/** @brief A stateful synchronization point.
	 * When an application is on a STATEFUL synchronization point, switching
	 * the current working mode requires to save some status. This could
	 * incur on an higher switching overhead */
	RTLIB_SYNC_STATEFUL
} RTLIB_SyncType_t;

/**
 * @brief The assigned resource types
 * @ingroup rtlib_sec03_plain_exc
 *
 * This enumerated type lists all the types of resources that the
 * BarbequeRTRM can assign to the application.
 */
typedef enum RTLIB_ResourceType
{
	SYSTEM = 0,
	CPU,
	PROC_NR,
	PROC_ELEMENT,
	MEMORY,
	GPU,
	ACCELERATOR,
} RTLIB_ResourceType_t;

/**
 * @brief The recipe of an Execution Context (EXC).
 * @ingroup rtlib_sec03_plain_exc
 *
 * @note This name must never exceed the size specified by
 * RTLIB_RECIPE_NAME_LENGTH
 */
typedef const char * RTLIB_Recipe_t;

/**
 * @brief An "execution context" handler.
 * @ingroup rtlib_sec03_plain_exc
 *
 * This handler must be used to uniquely identify a previously registered
 * execution context. Such a handler is passed back to the application by the
 * resource manager each time it needs to communicate some information.
 */
typedef RTLIB_EXCParameters_t * RTLIB_EXCHandler_t;


/*******************************************************************************
 *    RTLib Data Structures
 ******************************************************************************/

/**
 * @brief The Barbeque API version number.
 * @ingroup rtlib_sec03_plain_services
 */
struct RTLIB_APIVersion
{
	/** Major API version number */
	int32_t major;
	/** Minor API version number */
	int32_t minor;
};

typedef struct RTLIB_SystemResources
{
	/** The system ID **/
	int16_t sys_id = 0;
	/** Number of CPU (processors) assigned */
	int16_t number_cpus = 0;
	/** Number of processing elements assigned */
	int16_t number_proc_elements = 0;
	/** Amount of processing quota assigned */
	int32_t cpu_bandwidth = 0;
	/** Amount of memory assigned */
	int32_t mem_bandwidth = 0;
	int32_t gpu_bandwidth = 0;
	int32_t acc_bandwidth = 0;

#ifdef CONFIG_TARGET_OPENCL
	/** The ID of the assigned OpenCL device */
	int32_t ocl_platform_id;
	int8_t ocl_device_id;
#endif

} RTLIB_SystemResources_t;

/**
 * @brief The information passed to an application to set its new Working Mode.
 * @ingroup rtlib_sec03_plain_exc
 */
struct RTLIB_WorkingModeParams
{
	/** The ID of the working mode */
	int8_t awm_id = -1;
	/** The set of platform supported services */
	const RTLIB_Services_t * services;

	/** Number of systems **/
	int16_t nr_sys = -1;
	/** The array of systems containing resources **/
	RTLIB_SystemResources_t * systems = nullptr;
};

/**
 * @brief The parameters to register an execution context.
 * @ingroup rtlib_sec03_plain_exc
 *
 * Contains all the information that an application must provide to the RTLib
 * upon library initialization (e.g. version, interfacing functions, and
 * programming language).
 */
struct RTLIB_EXCParameters
{
	/** The "execution context" implemented API version */
	RTLIB_APIVersion_t version;
	/** The application code language */
	RTLIB_ProgrammingLanguage_t language;
	/** The identifier of the "execution context" recipe */
	RTLIB_Recipe_t recipe;
};

/**
 * @brief A constraint asserted on recipe specified working modes
 * @ingroup rtlib_sec03_plain_constr
 *
 * Applications have an associated set of working modes, each one defining a
 * certain amount of resources usage.  Applications could assert some
 * constraints at run-time, to invalidate a subset of its own working modes.
 */
struct RTLIB_Constraint
{
	/** The identified of an Application Working Mode (AWM) */
	uint8_t awm;
	/** The required operation on the previous AWM */
	RTLIB_ConstraintOperation_t operation;
	/** The constraint boundary */
	RTLIB_ConstraintType_t type;
};

/*******************************************************************************
 *    RTLib "plain" API (RSD)
 ******************************************************************************/

/**
 * @name EXC Management Functions
 *
 * @{
 */

/**
 * @brief Pointer to an EXC registration function
 * @ingroup rtlib_sec03_plain_exc
 *
 * A function implemented by the RTLib which allows an application to register
 * an "execution context" (EXC) to the Barbeque run-time manager, by provinding
 * all the parameters required by the RTLIB_RegisterParams struct.
 *
 * @param name the EXC name
 * @param params the EXC registration parameters
 *
 * @return an handler to the registered execution context, or NULL on errors.
 *
 * @note This schema allows a single application to register different
 * "execution contexts". Each "execution context", from the prespective of the
 * Barbeque run-time manager is a independent entity which require access to
 * computation fabric resources based on its proper "working modes".
 */
typedef RTLIB_EXCHandler_t(*RTLIB_Register_t)(
					      const char * name,
					      const RTLIB_EXCParameters_t * params);

/**
 * @brief Sets up cgroups for this exc
 * @ingroup rtlib_sec03_plain_exc
 *
 */
typedef RTLIB_ExitCode_t(*RTLIB_SetupCGroups_t)(
						const RTLIB_EXCHandler_t exc_handler);

/**
 * @brief Pointer to an EXC enabling function
 * @ingroup rtlib_sec03_plain_exc
 *
 * This function is provided by the RTLib to enable the scheduling of the
 * specified EXC. The specified execution context must have been previouslty
 * registered.  A call to this method will switch the EXC state to READY, thus
 * making it eligible for resources allocation.
 *
 * @param ech the handlers of the EXC to enable.
 *
 * @return RTLIB_OK on enabling success, an error exit code otherwise.
 *
 * @note This call enable the EXC but does not require the Barbeque RTRM to
 * schedule resources for this EXC as soon as possible.  Indeed, after this
 * call returns, the application must issue a GetWorkingMode() to actually get
 * an AWM assigned.
 */
typedef RTLIB_ExitCode_t(*RTLIB_Enable_t)(const RTLIB_EXCHandler_t exc_handler);

/**
 * @brief Pointer to an EXC disabling function.
 * @ingroup rtlib_sec03_plain_exc
 *
 * This function is provided by the RTLib to disable the scheduling of the
 * specified EXC. The specified execution context must have been previouslty
 * registered.  A call to this method will switch the EXC state to DISABLED,
 * thus making it not more eligible for resources allocation and forcing a
 * release of all the resources eventaully assigned to the specified EXC.
 *
 * @param ech the handler of the EXC to disable
 *
 * @return RTLIB_OK on disabling success, an error exit code otherwise.
 *
 * @note This call ask the Barbeque RTRM to release schedule resources for
 * this EXC as soon as possible.
 */
typedef RTLIB_ExitCode_t(*RTLIB_Disable_t)(const RTLIB_EXCHandler_t exc_handler);

/**
 * @brief Pointer to an EXC un-registration function.
 * @ingroup rtlib_sec03_plain_exc
 *
 * A function implemented by the RTLib which allows an application to
 * unregister a previously defined "execution context" (EXC).  This call will
 * release all the resources currently allocated to the specified EXC.
 *
 * @param ech the handler of the EXCs to undergister.
 */
typedef void (*RTLIB_Unregister_t)(const RTLIB_EXCHandler_t exc_handler);

typedef void (*RTLIB_Terminate_t)();

/**@}*/

/**
 * @name Constraints Management Functions
 *
 * ADD DESCRIPTION HERE
 *
 * @{
 */

/**
 * @brief Pointer to an EXC constraint assert function.
 * @ingroup rtlib_sec03_plain_constr
 *
 * An execution context (EXC) could assert a constraint to the Barbeque RTRM, so
 * that it could do the best to schedule for this EXC a working mode which is
 * compliant with the requirement. An application could assert a set of
 * constraints at run-time to invalidate certain working modes.
 *
 * @param constraints a vector of constraints to be asserted
 * @param count the number of constraint to be asserted
 *
 * @note the Barbeque RTRM will do the best to satisfy a constraint
 * requirements, however, it is worth to notice that, since we are in a mixed
 * workload scenario, it could be not possible to achieve such a result.
 * Thus, an application asserting a constraint <em>must</em> wait for a
 * confirm response from Barbeque before accessing the required
 * resources, this is particularly critical in the case the EXC want to
 * increase the used resource (i.e. setting a lower bound higher than the
 * working mode currently in use).
 */
typedef RTLIB_ExitCode_t(*RTLIB_SetConstraints_t)(
						  RTLIB_EXCHandler_t exc_handler,
						  RTLIB_Constraint_t * constraints,
						  uint8_t count);

/**
 * @brief Pointer to an EXC contraint release function.
 * @ingroup rtlib_sec03_plain_constr
 */
typedef RTLIB_ExitCode_t(*RTLIB_ClearConstraints_t)(
						    RTLIB_EXCHandler_t exc_handler);

/**
 * @brief Pointer to an EXC Goal Gap assert function.
 * @ingroup rtlib_sec03_plain_constr
 *
 * An execution context (EXC) could assert a "Goal Gap" relative to the
 * current assigned AWM if the expected QoS level is lower that its actual
 * value. Thus, the Barbeque RTRM could do the best to schedule for this EXC a
 * working mode which tries to assign more resources to to its in order to
 * compensate the asserted gap. This API is completely agnostic on how a goal
 * is computed and makes just one assumption: by increasing the resources
 * assigned to the demanding task we could try to compensate the asserted gap.
 * The more the gap, the more resources are required in addition by the
 * application.
 *
 * The "Goal Gap" (GG) is represented as an integer percentage, i.e. an
 * integer number in the range (0,100]. The higher the gap the more resources
 * are required by the application, with respect to the resources corresponding
 * to the currently assigned AWM.
 *
 * By issuing such a call, the application is giving just an hit to the
 * Barbeque RTRM scheduler. This means that, as soon as it will be possible,
 * it will try to assign an higher value AWM to the demanding application.
 *
 * @param gap the Goal Gap (GG) percentage, to be represented as a number in
 * the range (0,100].
 */
typedef RTLIB_ExitCode_t(*RTLIB_SetGoalGap_t)(
					      RTLIB_EXCHandler_t exc_handler,
					      int gap);
/**@}*/

/**
 * @name Run-Time Management Functions
 *
 * ADD DESCRIPTION HERE
 *
 * @{
 */

/**
 * @brief Synchronization point notification and AWM authorization.
 * @ingroup rtlib_sec03_plain_rtm
 *
 * An execution context (EXC) is encouraged to support the Barbeque RTRM by
 * notifying the reaching of a synchronization point. A synchronization point
 * is a point during the workload processing, when the EXC is on a consistent
 * state, i.e. a changing of working mode has the lower impact on both
 * performances and workload trashing. Some example of synchronization point
 * could be: the end of a frame decoding for a video decoding application,
 * the end of a packet processing for networking applications.  The execution
 * context is required to notify these events to the RTLib which in turns
 * could exploit them to better arrange working modes reconfiguration among
 * all the active applications.
 *
 * Moreover, in a Run-Time Resource Managed system the Barbeque RTRM has the
 * role to assigned an Operating Point to each active application. Thus, each
 * application is required to call this method every time a Working Mode
 * change could be expected, i.e. at each synchronization point or when a
 * working mode should be initially assigned after the EXC has been enabled.
 *
 * Thus, at each synchronization point the application is required to call
 * this method and decide what to do based on the returned code.  If a working
 * mode change is required by the Barbeque RTRM, this method returns an error
 * which could be used to identify the kind of reconfiguration required.
 * Please not that, in each of this last cases, the application is expected to
 * perform the required re-configuration and then to call this method again to
 * get the authorization on using it. Indeed, this second call is used the the
 * RTLib to know that a reconfiguration has been completed thus notifying the
 * Barbeque RTRM, but also to collect useful statistics on reconfigurations
 * overhead in an application transparent way.
 *
 * @param ech the handler of the EXC to configure
 * @param wm a pointer to the selected working mode
 * @param st the kind of this synchronization point
 *
 * @return RTLIB_OK if a working mode has been assigned, RTLIB_EXC_GWM_FAILED
 * if a working mode could not been assigned. A value between
 * RTLIB_EXC_GWM_START and RTLIB_EXC_GWM_BLOCKED if a reconfiguration is
 * required. Please not that, in each of this last cases, the application is
 * expected to perform the required re-configuration and then to call this
 * method again to get the authorization on using it. Indeed, this second call
 * is used the the RTLib to know that a reconfiguration has been completed
 * thus notifying the Barbeque RTRM, but also to collect useful statistics on
 * reconfigurations overhead in an application transparent way.
 *
 * @note this method is blocking, the application could be "suspended" on this
 * call until a new working mode has been assigned to it.
 */
typedef RTLIB_ExitCode_t(*RTLIB_GetWorkingMode_t)(
						  RTLIB_EXCHandler_t exc_handler,
						  RTLIB_WorkingModeParams_t * wm,
						  RTLIB_SyncType_t st);

/**@}*/

/*******************************************************************************
 *    Utility Functions Support
 ******************************************************************************/

/**
 * @name Utility Functions
 *
 * ADD DESCRIPTION HERE
 *
 * @{
 */

/**
 * @brief Get the BarbequeRTRM application UID
 * @ingroup rtlib_sec03_plain_cps
 *
 * Every application is identified within BBQ by a unique identified (UID).
 * This function return a reference to the string representing this
 * identified, which could be conveniently used to support logging.
 */
typedef const char * (*RTLIB_Utils_GetCharUniqueID)();

/**
 * @brief The type used to represent application UIDs
 */
typedef BBQUE_UID_TYPE AppUid_t;

/**
 * @brief Get the BarbequeRTRM EXC UID
 * @ingroup rtlib_sec03_plain_cps
 *
 * Every EXC of an application is identified within BBQ by a unique identified
 * (UID), which could be recovered with by using this method.
 */
typedef AppUid_t(*RTLIB_Utils_GetUniqueID)(RTLIB_EXCHandler_t exc_handler);

/**
 * @brief Get the amount of resources assigned by the BarbequeRTRM
 * @ingroup rtlib_sec03_plain_rtrm
 *
 * Every scheduled EXC gets a certain amount of resources. By specifying
 * the required resource type, the application can read the related
 * assigned amount.
 */
typedef RTLIB_ExitCode_t(*RTLIB_Utils_GetResources) (
						     RTLIB_EXCHandler_t exc_handler,
						     const RTLIB_WorkingModeParams_t * working_mode_params,
						     RTLIB_ResourceType_t resource_type,
						     int32_t & resource_amount);

typedef RTLIB_ExitCode_t(*RTLIB_Utils_GetAffinityMask) (
							RTLIB_EXCHandler_t exc_handler,
							const RTLIB_WorkingModeParams_t * working_mode_params,
							int32_t * ids_vector,
							int vector_size);

/**
 * @brief Get the amount of resources assigned by the BarbequeRTRM to the
 *        various systems. System[0] is the local system.
 * @ingroup rtlib_sec03_plain_rtrm
 *
 * Every scheduled EXC gets a certain amount of resources. By specifying
 * the required resource type, the application can read the related
 * assigned amount.
 */
typedef RTLIB_ExitCode_t(*RTLIB_Utils_GetResourcesArray) (
							  RTLIB_EXCHandler_t exc_handler,
							  const RTLIB_WorkingModeParams_t * working_mode_params,
							  RTLIB_ResourceType_t resource_type,
							  int32_t * assignment_per_system,
							  uint16_t number_of_systems);

typedef void (*RTLIB_Utils_StartPCountersMonitoring) (
						      RTLIB_EXCHandler_t exc_handler);


/**@}*/

/*******************************************************************************
 *    Cycles Per Second (CPS) Control Support
 ******************************************************************************/

/**
 * @name CPS Management Functions
 *
 * ADD DESCRIPTION HERE
 *
 * @{
 */

/**
 * @brief Setup the Cycles Per Seconds (CPS) support
 * @ingroup rtlib_sec03_plain_cps
 *
 * The RTLib provides the support to enforce a certain maximum cycles rate.
 * If a (not null) CPS has been specified, at run-time the library monitors
 * the time required by a cycle run and eventually add a suitable delay in
 * order to obtain the required cycles rate.
 *
 * @param ech the handler of the EXC to configure
 * @param cps the required Cycles Per Seconds [Hz]
 */
typedef RTLIB_ExitCode_t(*RTLIB_CPS_Set)(
					 RTLIB_EXCHandler_t exc_handler,
					 float cycles_per_second);

/**
 * @brief Get the measured Cycles Per Seconds (CPS)
 * @ingroup rtlib_sec03_plain_cps
 *
 * The RTLib provides the support to monitor the actual cycle rate an
 * application is achieving at run-time. This method allows to get an
 * estimation of the current cycle rate.
 *
 * @param ech the handler of the EXC to configure
 *
 * @return the measured cycle rate
 */
typedef float (*RTLIB_CPS_Get)(
			       RTLIB_EXCHandler_t exc_handler);

/**
 * @brief Get the measured execution time
 * @ingroup rtlib_sec03_plain_cps
 *
 * @return the measured execution time
 */
typedef uint32_t(*RTLIB_CPS_GetExecTime)(
					 RTLIB_EXCHandler_t exc_handler);


/**
 * @brief Get the measured Jobs Per Seconds (JPS)
 * @ingroup rtlib_sec03_plain_cps
 *
 * The RTLib provides you the support to monitor the actual jobs rate an
 * application is achieving at run-time. This method allows to get an
 * estimation of the current jobs rate.
 *
 * @param ech the handler of the EXC to configure
 *
 * @return the measured jobs rate
 */
typedef float (*RTLIB_JPS_Get)(
			       RTLIB_EXCHandler_t exc_handler);

/**
 * @brief Update JPC value
 * @ingroup rtlib_sec03_plain_cps
 *
 * The RTLib provides you the support to monitor the actual jobs rate an
 * application is achieving at run-time. This method allows to get an
 * estimation of the current jobs rate. JPS is computed using CPS and the
 * number of executed Jobs Per Cycle (JPC). Upon changing JPC value, the
 * application should notify it to bbque by using this function.
 *
 * @param ech the handler of the EXC to configure
 * @param jpc the new value for JPC
 *
 * @return the measured jobs rate
 */
typedef RTLIB_ExitCode_t(*RTLIB_JPC_Update)(
					    RTLIB_EXCHandler_t exc_handler, int jpc);

/**
 * @brief Setup the Cycles Per Seconds (CPS) goal
 * @ingroup rtlib_sec03_plain_cps
 *
 * The RTLib provides the support to specify a certain cycle rate goal.
 * If the goal is not matched, a SetGoalGap request is sent to the
 * BarbequeRTRM daemon.
 *
 * @param ech the handler of the EXC to configure
 * @param cps_min the minimum required Cycles Per Seconds [Hz]
 * @param cps_max the maximum required Cycles Per Seconds [Hz]
 */
typedef RTLIB_ExitCode_t(*RTLIB_CPS_Goal_Set)(
					      RTLIB_EXCHandler_t exc_handler, float cps_min, float cps_max);

/**
 * @brief Setup the Jobs Per Seconds (JPS) goal
 * @ingroup rtlib_sec03_plain_cps
 *
 * The RTLib provides the support to specify a certain jobs rate goal.
 * If the goal is not matched, a SetGoalGap request is sent to the
 * BarbequeRTRM daemon.
 *
 * @param exc_handler the handler of the EXC to configure
 * @param jps_min the minimum required Jobs Per Seconds [Hz]
 * @param jps_max the maximum required Jobs Per Seconds [Hz]
 * @param jpc the number of jobs that are currently processed each cycle
 */
typedef RTLIB_ExitCode_t(*RTLIB_JPS_Goal_Set)(
					      RTLIB_EXCHandler_t exc_handler,
					      float jps_min, float jps_max, int jpc);

/**
 * @brief Setup the Cycles Time [us] support
 * @ingroup rtlib_sec03_plain_cps
 *
 * The RTLib provides the support to enforce a certain minimum cycles time.
 * If a (not null) [us] timing has been specified, at run-time the library
 * monitors the time required by a cycle run and eventually add a suitable
 * delay in order to obtain the required cycles execution time.
 *
 * @param ech the handler of the EXC to configure
 * @param cps the required Cycles Per Seconds [Hz]
 */
typedef RTLIB_ExitCode_t(*RTLIB_CPS_CTimeUs)(
					     RTLIB_EXCHandler_t exc_handler,
					     uint32_t us);

/**@}*/

/*******************************************************************************
 *    Performance Monitoring Support
 ******************************************************************************/

/**
 * @name Monitors Management Functions
 *
 * ADD DESCRIPTION HERE
 *
 * @{
 */


/**
 * @brief Notify the RTLib an EXC has completed
 * @ingroup rtlib_sec03_plain_perf
 *
 * Once an EXC has completed its workload, an application is encouraged to
 * notify the run-time library by calling this method.  This could be used by
 * the RTLib implementation to properly release all the resources used to
 * monitor application perforamnces.
 *
 * @param ech the handler of the EXC to configure
 */
typedef void (*RTLIB_Notify_Exit)(
				  RTLIB_EXCHandler_t exc_handler);

/**
 * @brief Notify the RTLib a "reconfiguration" is starting
 * @ingroup rtlib_sec03_plain_perf
 *
 * Once a working mode reconfiguration is starting, an application is
 * encouraged to notify the run-time library by calling this method. This
 * could be used by the RTLib implementation to collect suitable information
 * and statistics on reconfigurations.
 *
 * @param ech the handler of the EXC to configure
 */
typedef void (*RTLIB_Notify_PreConfigure)(
					  RTLIB_EXCHandler_t exc_handler);

/**
 * @brief Notify the RTLib a "reconfiguration" has completed
 * @ingroup rtlib_sec03_plain_perf
 *
 * Once a working mode reconfiguration has been completed, an application is
 * encouraged to notify the run-time library by calling this method. This
 * could be used by the RTLib implementation to collect suitable information
 * and statistics on reconfigurations.
 *
 * @param ech the handler of the EXC to configure
 */
typedef void (*RTLIB_Notify_PostConfigure)(
					   RTLIB_EXCHandler_t exc_handler);

/**
 * @brief Notify the RTLib a "run" is starting
 * @ingroup rtlib_sec03_plain_perf
 *
 * Once a new processing cycle is starting, an application is encouraged to
 * notify the run-time library by calling this method. This could be used by
 * the RTLib implementation to collect suitable information and statistics on
 * application processing.
 *
 * @param ech the handler of the EXC to configure
 */
typedef void (*RTLIB_Notify_PreRun)(
				    RTLIB_EXCHandler_t exc_handler);


/**
 * @brief Notify the RTLib a "run" has completed
 * @ingroup rtlib_sec03_plain_perf
 *
 * Once a new processing cycle has been completed, an application is
 * encouraged to notify the run-time library by calling this method. This
 * could be used by the RTLib implementation to collect suitable information
 * and statistics on application processing.
 *
 * @param ech the handler of the EXC to configure
 */
typedef void (*RTLIB_Notify_PostRun)(
				     RTLIB_EXCHandler_t exc_handler);

/**
 * @brief Notify the RTLib a "monitor" is starting
 * @ingroup rtlib_sec03_plain_perf
 *
 * Once a new QoS monitor is starting, an application is encouraged to
 * notify the run-time library by calling this method. This could be used by
 * the RTLib implementation to collect suitable information and statistics on
 * application performance monitoring.
 *
 * @param ech the handler of the EXC to configure
 */
typedef void (*RTLIB_Notify_PreMonitor)(
					RTLIB_EXCHandler_t exc_handler);


/**
 * @brief Notify the RTLib a "monitor" has completed
 * @ingroup rtlib_sec03_plain_perf
 *
 * Once a new QoS monitor has been completed, an application is
 * encouraged to notify the run-time library by calling this method. This
 * could be used by the RTLib implementation to collect suitable information
 * and statistics on application performance monitoring.
 *
 * @param ech the handler of the EXC to configure
 */
typedef void (*RTLIB_Notify_PostMonitor)(
					 RTLIB_EXCHandler_t exc_handler);

/**
 * @brief Notify the RTLib a "suspend" is starting
 * @ingroup rtlib_sec03_plain_perf
 *
 * Once a working mode suspension is starting, an application is encouraged to
 * notify the run-time library by calling this method. This could be used by
 * the RTLib implementation to collect suitable information and statistics on
 * application suspension overheads.
 *
 * @param ech the handler of the EXC to configure
 */
typedef void (*RTLIB_Notify_PreSuspend)(
					RTLIB_EXCHandler_t exc_handler);


/**
 * @brief Notify the RTLib a "suspend" has completed
 * @ingroup rtlib_sec03_plain_perf
 *
 * Once a working mode suspension has been completed, an application is
 * encouraged to notify the run-time library by calling this method. This
 * could be used by the RTLib implementation to collect suitable information
 * and statistics on application suspension overheads.
 *
 * @param ech the handler of the EXC to configure
 */
typedef void (*RTLIB_Notify_PostSuspend)(
					 RTLIB_EXCHandler_t exc_handler);

/**
 * @brief Notify the RTLib a "resume" is starting
 * @ingroup rtlib_sec03_plain_perf
 *
 * Once a working mode resume is starting, an application is encouraged to
 * notify the run-time library by calling this method. This could be used by
 * the RTLib implementation to collect suitable information and statistics on
 * application resume overheads.
 *
 * @param ech the handler of the EXC to configure
 */
typedef void (*RTLIB_Notify_PreResume)(
				       RTLIB_EXCHandler_t exc_handler);


/**
 * @brief Notify the RTLib a "resume" has completed
 * @ingroup rtlib_sec03_plain_perf
 *
 * Once a working mode resume has been completed, an application is
 * encouraged to notify the run-time library by calling this method. This
 * could be used by the RTLib implementation to collect suitable information
 * and statistics on application resume overheads.
 *i
 * @param ech the handler of the EXC to configure
 */
typedef void (*RTLIB_Notify_PostResume)(
					RTLIB_EXCHandler_t exc_handler);


/**
 * @brief Release the RTLib notification support
 * @ingroup rtlib_sec03_plain_perf
 *
 * Once an application is going to exit, before to release all its resources,
 * an application is encouraged to notify the run-time library by calling this
 * method. This could be used by the RTLib implementation to collect suitable
 * information and statistics immediately before the application termination.
 *
 * @param ech the handler of the EXC to configure
 */
typedef void (*RTLIB_Notify_Release)(
				     RTLIB_EXCHandler_t exc_handler);

/**@}*/



/*******************************************************************************
 *    RTLib Configuration
 ******************************************************************************/

/**
 * @name Library Configuration
 *
 * This is a collection of configuration flags for the Library.
 * Most of these flags could be configured at library initialization
 * time via the BBQUE_RTLIB_OPTS environment variable.
 *
 * @{
 */

#define BBQUE_RTLIB_OPTS_TAG_MAX 6

typedef struct RTLIB_Config
{
	// Profiling configuration

	struct profiling
	{
		bool enabled = false;

		struct
		{
			bool global = false;
			bool overheads = false;
			bool no_kernel = false;
			bool big_num = false;
			int detailed_run = 0;
			int raw = 0;
		} perf_counters;

		struct
		{
			bool file = false;

			// CSV format output

			struct
			{
				bool enabled = false;
				const char * separator = " ";
			} CSV;
		} output;

		struct
		{
			bool enabled = false;
			int level = 0;
		} opencl;

	} profile;

	// Application-Specific RTM

	struct
	{
		uint16_t rt_profile_rearm_time_ms =
			BBQUE_DEFAULT_RTLIB_RTPROF_REARM_TIME_MS;
		uint16_t rt_profile_wait_for_sync_ms =
			BBQUE_DEFAULT_RTLIB_RTPROF_WAIT_FOR_SYNC_MS;
	} runtime_profiling;

	// Unmanaged execution

	struct
	{
		bool enabled = false;
		int awm_id = 0;
	} unmanaged;

	// CGroup enforcing

	struct
	{
#ifdef CONFIG_BBQUE_CGROUPS_DISTRIBUTED_ACTUATION
		bool enabled = true;
#else
		bool enabled = false;
#endif

		bool static_configuration = false;

		// CUPSET Contoller

		struct
		{
			char * cpus = nullptr;
			char * mems = nullptr;
		} cpuset;

		// CPU Controller

		struct
		{
			char * cfs_period_us = nullptr;
			char * cfs_quota_us = nullptr;
		} cpu;

		// MEMORY Contoller

		struct
		{
			char * limit_in_bytes = nullptr;
		} memory;

	} cgroup_support;

	// Processing duration

	struct
	{
		bool enabled = false;
		bool time_limit = false;
		uint32_t max_cycles_before_termination = 0;
		uint32_t max_ms_before_termination = 0;
	} duration;

} RTLIB_Conf_t;

/**@}*/

/*******************************************************************************
 *    RTLib Services Descriptor (RSD)
 ******************************************************************************/

/**
 * @name Library Intialization
 *
 * ADD DESCRIPTION HERE (Library Iitialization)
 *
 * @{
 */

/**
 * @brief Information passed to the application at RTLib initialization time.
 * @ingroup rtlib_sec03_plain_services
 *
 * This struct aggregate all the services that the Barbeque provides to
 * application (e.g., version, registeration of "execution contexts" and
 * service functions). This struct is passed to each application at library
 * initialization time.
 */
struct RTLIB_Services
{
	/** Current version of the plugins API */
	RTLIB_APIVersion_t version;
	/** The RTLib configuration */
	const RTLIB_Conf_t * config;
	/** Execution contexts registration
	 * Applications use this function at RTLib library initialization
	 * time to register each "execution context" they want. */
	RTLIB_Register_t Register;
	RTLIB_SetupCGroups_t SetupCGroups;
	/** Execution contexts scheduing
	 * Applications use this function to ask resources for a specified EXCs
	 * (ar all the registered ones).*/
	RTLIB_Enable_t EnableEXC;
	/** Notify synchronization and get the assigned Working Mode.
	 * Applications call this method, during the initialization or after a
	 * false returning sync, to get a reference to the new assigned
	 * working mode. */
	RTLIB_GetWorkingMode_t GetWorkingMode;
	/** Constraints assertion on a recipe working modes An execution
	 * context could set a boundary on a set of working modes to consider
	 * at run-time for resource scheduling. The Barbeque RTRM resource
	 * scheduling of working modes should satisfying these requirement. */
	RTLIB_SetConstraints_t SetAWMConstraints;
	/** Constraints removal on recipe working modes */
	RTLIB_ClearConstraints_t ClearAWMConstraints;
	/** Goal Gap (GG) assertion on recipe working modes An execution
	 * context could sssert a goal gap relative to the currently assigned
	 * AWM if the expected QoS level is lower that its actual value. */
	RTLIB_SetGoalGap_t SetGoalGap;
	/** Execution contexts release
	 * Applications use this function to release resources for a specified
	 * EXCs (ar all the scheduled ones).*/
	RTLIB_Disable_t Disable;
	/** Execution contexts un-registration
	 * Applications use this function to un-register an "execution
	 * context" */
	RTLIB_Unregister_t Unregister;
	/** Termination function to close the communication with the resource
	 * manager daemon */
	RTLIB_Terminate_t Terminate;

	/* Utility function interface */
	struct
	{
		RTLIB_Utils_GetCharUniqueID GetUniqueID_String;
		RTLIB_Utils_GetUniqueID GetUniqueID;
		RTLIB_Utils_GetResources GetResources;
		RTLIB_Utils_GetAffinityMask GetAffinityMask;
		RTLIB_Utils_GetResourcesArray GetResourcesArray;
		RTLIB_Utils_StartPCountersMonitoring MonitorPerfCounters;
	} Utils;

	/* Cycles Time Control interface */
	struct
	{
		RTLIB_CPS_Set Set;
		RTLIB_CPS_Get Get;
		RTLIB_CPS_Goal_Set SetGoal;
		RTLIB_CPS_CTimeUs SetMinCycleTime_us;
		RTLIB_CPS_GetExecTime ExecTime_ms;
	} CPS;

	/* Cycles Time Control interface */
	struct
	{
		RTLIB_JPS_Get Get;
		RTLIB_JPS_Goal_Set SetGoal;
		RTLIB_JPC_Update UpdateJPC;
	} JPS;

	/* Performance estimation and notification interface */
	struct
	{
		RTLIB_Notify_Exit Exit;
		RTLIB_Notify_PreConfigure PreConfigure;
		RTLIB_Notify_PostConfigure PostConfigure;
		RTLIB_Notify_PreRun PreRun;
		RTLIB_Notify_PostRun PostRun;
		RTLIB_Notify_PreMonitor PreMonitor;
		RTLIB_Notify_PostMonitor PostMonitor;
	} Notify;
};

/**
 * @brief The RTLib library entry point.
 * @ingroup rtlib_sec03_plain_services
 *
 * This function must be the first one called by an application to properly
 * initialized the RTLib.  Library initialization is required to propery setup
 * the communication channel with the Barbeque RTRM and prepare the ground for
 * EXC management.
 *
 * @param name the name of the calling application, this name will be used
 * by both the Barbeque RTRM and the RTLib for tracing purposes. The name
 * should not exceed the value defined by RTLIB_APP_NAME_LENGTH.
 *
 * @param services a pointer to a pointer to an RTLib services struct. Such
 * struct will provide the handlers for all the library provided services.
 * Thus, this is an output parameter which is not NULL only if the library
 * initialization success, i.e. this call return RTLIB_OK.
 *
 * @return RTLIB_OK on registration success, RTLIB_VERSION_MISMATCH if the
 * library verison does not match that of the running Barbeque instance,
 * RTLIB_CHANNEL_SETUP_FAILED if the library failed to setup a communication
 * channel with the Barbeque RTRM instance.
 */
RTLIB_ExitCode_t RTLIB_Init(
			    const char * name,
			    RTLIB_Services_t ** services,
			    pid_t restore_pid = 0);

/**@}*/

/* DEPRECATED API - Not To Be Used
 * @brief Application provided callback to stop the specified EXC.
 *
 * This function allow the run-time manager to (gracefully) stop an
 * application thus releasing resources it is using.  Each application is
 * required to registers such a functions with the RTLib at library
 * initialization time. Once this function returns, or the specified timeout
 * expires [us], the Barbeque RTRM is authorized to forcely stop the
 * application, i.e. kill and release all the resources.
 *
 * @note after such a call the application is not forced to completely exit,
 * instead it could wait for resources becoming available and assigned and
 * then restert the processing from the point it was suspended.
 * If properly handled, this mechanism should allows to easily support more
 * advanced suspension/hibernation features.
 */
typedef RTLIB_ExitCode_t(*RTLIB_Stop_t)(
					RTLIB_EXCHandler_t exc_handler,
					struct timespec timeout);

/*******************************************************************************
 *    RTLib Utils
 ******************************************************************************/

/**
 * @name Errors Handling Support
 *
 * ADD DESCRIPTION HERE
 *
 * @{
 */

/**
 * @brief A stringified rapresentation of error messages
 * @ingroup rtlib_sec03_plain_services
 */
extern const char * RTLIB_errorStr[];

/**
 * @brief Get a string description for the specified RTLib error
 * @ingroup rtlib_sec03_plain_services
 */
inline char const * RTLIB_ErrorStr(RTLIB_ExitCode_t result)
{
	assert(result < RTLIB_EXIT_CODE_COUNT);
	return RTLIB_errorStr[result];
}

/**@}*/

#ifdef  __cplusplus
}
#endif

#endif // BBQUE_RTLIB_H_
