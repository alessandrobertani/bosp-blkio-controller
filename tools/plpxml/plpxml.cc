/*
 * Copyright (C) 2016  Politecnico di Milano
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Federico Reghenzani <federico1.reghenzani@mail.polimi.it>
 */

#include <iostream>

#include "plp_translator.hpp"

#define DEBUG 0

namespace bbque {
namespace tools {

/**
 * This function implements the Bernstein hash algorithm to transform a
 * std::string into an integer.
 */
constexpr unsigned int bhash(const char* source, int h = 0)
{
	return !source[h] ? 5381 : (bhash(source, h+1) * 33) ^ source[h];
}

/**
 * Parse the command line arguments
 */
void manage_v_arg(std::string arg, plp_data_t* data) {
	unsigned long pos = arg.find_first_of("=");

	if (pos == std::string::npos) {
		// Malformed
		std::cerr << "WARNING: Malformed argument, ignoring" << std::endl;
		return;
	}

	std::string content = arg.substr(pos+1);

	switch (bhash(arg.substr(0,pos).c_str())) {
	case bhash("BBQUE_UID"):
		data->user_id = content;
		break;
	case bhash("BBQUE_GID"):
		data->group_id = content;
		break;
	case bhash("BBQUE_CPUP"):
		data->cfs_cpu_period = content;
		break;
	case bhash("BBQUE_PLAT_CPUS"):
		data->system_cpuset = content;
		break;
	case bhash("BBQUE_PLAT_MEMS"):
		data->system_mems = content;
		break;
	case bhash("BBQUE_PLAT_CPUS_EX"):
		data->cpu_exclusive = content;
		break;
	case bhash("BBQUE_PLAT_MEMS_EX"):
		data->mem_exclusive = content;
		break;
	case bhash("BBQUE_FEAT_CPUQ"):
		data->cpu_controller_available = content;
		break;
	case bhash("BBQUE_FEAT_MEMC"):
		data->memory_controller_available = content;
		break;

	default:
		std::cerr << "WARNING: argument " << arg.substr(0,pos)
		          <<" unknown, ignoring"  << std::endl;
		break;
	}

}

int plpxml(int argc, char** argv) {

	int err;
	plp_data_t data;

	// Default values:
	data.user_id  = "root";
	data.group_id = "root";
	data.cfs_cpu_period = "100000";


	// First of all search for -v arguments and the last filename
	std::string systems_file="";
	bool in_v = false;
	for (int i = 1; i < argc; i++) {
		if (in_v) {
			manage_v_arg(argv[i], &data);
			in_v = false;
			continue;
		}
		if(std::string(argv[i]) == "-v") {
			in_v=true;
		} else {
			systems_file = argv[i];
		}
	}

	if (systems_file.length() == 0 ) {
		std::cerr << "No input file specified." << std::endl;
		return 1;
	}

	PLPTranslator xml_translator(data);
	if ( (err = xml_translator.parse(systems_file)) != 0 )
		return err;

	std::cout << xml_translator.get_output() << std::endl;
	std::cout << "# File end - XML Parser" << std::endl;

	return 0;
} // plpxml


} // namespace tools
} // namespace bbque

int main(int argc, char** argv) {

	std::cout << "# File generated by XML Parser" << std::endl;

#if DEBUG
	// Print arguments in stderr
	for (int i = 0; i < argc; i++)
		std::cerr << "# ARG " << argv[i] << std::endl;
#endif

	return bbque::tools::plpxml(argc,argv);
}
